image: docker:25.0.3
services: ["docker:25.0.3-dind"]
variables:
  DOCKER_DRIVER: overlay2
  TAG: "$CI_COMMIT_SHORT_SHA"

stages: [test, build, push, deploy]

pytest:
  stage: test
  image: python:3.12-slim
  before_script:
    - pip install -r requirements.txt
  script:
    - pytest -q

build:
  stage: build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - docker build -t "$CI_REGISTRY_IMAGE:$TAG" -t "$CI_REGISTRY_IMAGE:latest" --build-arg BUILD_TARGET=prod .

push:
  stage: push
  script:
    - docker push "$CI_REGISTRY_IMAGE:$TAG"
    - docker push "$CI_REGISTRY_IMAGE:latest"
  needs: [build]

.deploy_template: &deploy
  stage: deploy
  image: alpine:3.20
  before_script:
    - apk add --no-cache openssh-client rsync curl
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | tr -d '
' > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa
    - ssh -o StrictHostKeyChecking=no "$DEPLOY_USER@$DEPLOY_HOST" 'echo ok'
  script:
    - |
      ssh "$DEPLOY_USER@$DEPLOY_HOST" <<'EOF'
      set -e
      export CI_REGISTRY_IMAGE="$CI_REGISTRY_IMAGE"
      export TAG="$TAG"
      export RELEASE_DIR="$DEPLOY_PATH"
      mkdir -p "$RELEASE_DIR"
      cd "$RELEASE_DIR"
      # Place les compose d'env si besoin (une seule fois)
      mkdir -p infra/compose infra/env || true
      # Pull & restart
      docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
      TAG="$TAG" CI_REGISTRY_IMAGE="$CI_REGISTRY_IMAGE" docker compose -f infra/compose/docker-compose.${ENV_TARGET}.yml pull
      TAG="$TAG" CI_REGISTRY_IMAGE="$CI_REGISTRY_IMAGE" docker compose -f infra/compose/docker-compose.${ENV_TARGET}.yml up -d
      docker system prune -f
      EOF

recette-deploy:
  <<: *deploy
  variables:
    ENV_TARGET: "recette"
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'

prod-deploy:
  <<: *deploy
  variables:
    ENV_TARGET: "prod"
  rules:
    - if: '$CI_COMMIT_TAG =~ /^prod-.*/'